"""
Gemini-based Utility Tool for DDV Product Advisor
Uses Gemini AI to parse and extract information from natural language
"""

import os
import json
import logging
from typing import Optional, Tuple, List, Dict, Any
from google import genai
from google.genai import types

logger = logging.getLogger(__name__)

class GeminiUtilsTool:
    """Utility tool using Gemini AI for flexible text processing"""
    
    def __init__(self):
        self.client = None
        self.model = "gemini-2.0-flash-lite"
        self._initialize_client()
    
    def _initialize_client(self):
        """Initialize Gemini client"""
        try:
            api_key = os.environ.get("GEMINI_API_KEY")
            if not api_key or api_key == "your_gemini_api_key_here":
                logger.warning("‚ö†Ô∏è GEMINI_API_KEY not found or invalid - Gemini features will be disabled")
                logger.info("üí° To enable Gemini features, set GEMINI_API_KEY in your environment or .env file")
                self.client = None
                return
            
            self.client = genai.Client(api_key=api_key)
            # Test the client with a simple call
            test_response = self.client.models.generate_content(
                model=self.model,
                contents=[types.Content(role="user", parts=[types.Part.from_text(text="test")])],
            )
            logger.info("‚úÖ Gemini Utils Tool initialized successfully")
        except Exception as e:
            logger.error(f"‚ùå Failed to initialize Gemini client: {e}")
            logger.warning("‚ö†Ô∏è Gemini features will be disabled - using fallback methods")
            self.client = None
    
    def is_available(self) -> bool:
        """Check if Gemini client is available"""
        return self.client is not None
    
    def _clean_json_response(self, response: str) -> str:
        """Clean JSON response from markdown code blocks"""
        if not response:
            return response
            
        cleaned = response.strip()
        if cleaned.startswith("```json"):
            cleaned = cleaned[7:]  # Remove ```json
        if cleaned.startswith("```"):
            cleaned = cleaned[3:]   # Remove ```
        if cleaned.endswith("```"):
            cleaned = cleaned[:-3]  # Remove ```
        
        return cleaned.strip()
    
    def _call_gemini(self, prompt: str, system_instruction: str) -> Optional[str]:
        """Call Gemini API with given prompt and system instruction"""
        if not self.client:
            logger.debug("üîß Gemini client not available - skipping AI processing")
            return None
        
        try:
            contents = [
                types.Content(
                    role="user",
                    parts=[types.Part.from_text(text=prompt)],
                ),
            ]
            
            generate_content_config = types.GenerateContentConfig(
                system_instruction=[types.Part.from_text(text=system_instruction)],
            )
            
            response = self.client.models.generate_content(
                model=self.model,
                contents=contents,
                config=generate_content_config,
            )
            
            return response.text.strip()
            
        except Exception as e:
            logger.error(f"‚ùå Gemini API call failed: {e}")
            return None
    
    def parse_price_from_text(self, text: str) -> Optional[int]:
        """Parse price from text using Gemini AI"""
        if not text:
            return None
        
        system_instruction = """
        Tr√≠ch xu·∫•t gi√° t·ª´ ƒëo·∫°n vƒÉn b·∫£n sau v√† tr·∫£ v·ªÅ d∆∞·ªõi d·∫°ng m·ªôt s·ªë nguy√™n.
        Lo·∫°i b·ªè t·∫•t c·∫£ c√°c k√Ω t·ª± kh√¥ng ph·∫£i l√† s·ªë v√† c√°c d·∫•u ph√¢n c√°ch h√†ng ngh√¨n.
        N·∫øu kh√¥ng t√¨m th·∫•y gi√° tr·ªã s·ªë h·ª£p l·ªá, h√£y tr·∫£ v·ªÅ null.
        Ch·ªâ tr·∫£ v·ªÅ s·ªë nguy√™n, kh√¥ng c√≥ text kh√°c.
        """
        
        prompt = f"Tr√≠ch xu·∫•t gi√° t·ª´: '{text}'"
        result = self._call_gemini(prompt, system_instruction)
        
        if result and result.lower() != "null":
            try:
                return int(result)
            except ValueError:
                logger.warning(f"‚ö†Ô∏è Could not parse price result: {result}")
                return None
        
        return None
    
    def extract_budget_from_text(self, text: str) -> Tuple[Optional[int], Optional[int]]:
        """Extract budget range from text using Gemini AI"""
        if not text or not self.is_available():
            return None, None
        
        system_instruction = """
        Ph√¢n t√≠ch y√™u c·∫ßu ng√¢n s√°ch t·ª´ ƒëo·∫°n vƒÉn b·∫£n v√† tr·∫£ v·ªÅ kho·∫£ng gi√° tr·ªã.
        
        Quy t·∫Øc ƒë·ªãnh nghƒ©a:
        - "gi√° r·∫ª" = d∆∞·ªõi 5 tri·ªáu VND
        - "t·∫ßm trung" = 5-15 tri·ªáu VND
        - "cao c·∫•p" = tr√™n 15 tri·ªáu VND
        - "d∆∞·ªõi X tri·ªáu" = d∆∞·ªõi X tri·ªáu VND
        - "t·ª´ X ƒë·∫øn Y tri·ªáu" = X-Y tri·ªáu VND
        - "t·∫ßm gi√° 20 tri·ªáu" = 20 tri·ªáu ƒë·∫øn 30 tri·ªáu
        - "kho·∫£ng 20 tri·ªáu" = 15 tri·ªáu ƒë·∫øn 25 tri·ªáu
        
        CH·ªà tr·∫£ v·ªÅ JSON thu·∫ßn t√∫y, KH√îNG c√≥ markdown code blocks:
        {"min": s·ªë_nguy√™n_ho·∫∑c_null, "max": s·ªë_nguy√™n_ho·∫∑c_null}
        
        V√≠ d·ª•: {"min": null, "max": 5000000} cho "gi√° r·∫ª"
        """
        
        prompt = f"Ph√¢n t√≠ch ng√¢n s√°ch t·ª´: '{text}'"
        result = self._call_gemini(prompt, system_instruction)
        
        if result:
            try:
                cleaned_result = self._clean_json_response(result)
                budget_data = json.loads(cleaned_result)
                min_budget = budget_data.get("min")
                max_budget = budget_data.get("max")
                return min_budget, max_budget
            except json.JSONDecodeError:
                logger.warning(f"‚ö†Ô∏è Could not parse budget result: {result}")
        
        return None, None
    
    def extract_brands_from_text(self, text: str) -> List[str]:
        """Extract brand preferences from text using Gemini AI"""
        if not text or not self.is_available():
            return []
        
        system_instruction = """
        Tr√≠ch xu·∫•t c√°c th∆∞∆°ng hi·ªáu ƒëi·ªán tho·∫°i t·ª´ ƒëo·∫°n vƒÉn b·∫£n.
        
        C√°c th∆∞∆°ng hi·ªáu ph·ªï bi·∫øn: Apple, Samsung, Xiaomi, Oppo, Vivo, Realme, OnePlus, Huawei, Nokia, Motorola
        
        CH·ªà tr·∫£ v·ªÅ JSON thu·∫ßn t√∫y, KH√îNG c√≥ markdown code blocks:
        ["brand1", "brand2", ...]
        N·∫øu kh√¥ng t√¨m th·∫•y th∆∞∆°ng hi·ªáu n√†o, tr·∫£ v·ªÅ []
        """
        
        prompt = f"Tr√≠ch xu·∫•t th∆∞∆°ng hi·ªáu t·ª´: '{text}'"
        result = self._call_gemini(prompt, system_instruction)
        
        if result:
            try:
                cleaned_result = self._clean_json_response(result)
                brands = json.loads(cleaned_result)
                if isinstance(brands, list):
                    return brands
            except json.JSONDecodeError:
                logger.warning(f"‚ö†Ô∏è Could not parse brands result: {result}")
        
        return []
    
    def extract_features_from_text(self, text: str) -> List[str]:
        """Extract feature requirements from text using Gemini AI"""
        if not text or not self.is_available():
            return []
        
        system_instruction = """
        Tr√≠ch xu·∫•t c√°c t√≠nh nƒÉng ƒëi·ªán tho·∫°i t·ª´ ƒëo·∫°n vƒÉn b·∫£n.
        
        C√°c t√≠nh nƒÉng ph·ªï bi·∫øn: camera, pin, m√†n h√¨nh, chip, ram, b·ªô nh·ªõ, h·ªá ƒëi·ªÅu h√†nh, wifi, bluetooth, gps
        
        CH·ªà tr·∫£ v·ªÅ JSON thu·∫ßn t√∫y, KH√îNG c√≥ markdown code blocks:
        ["feature1", "feature2", ...]
        N·∫øu kh√¥ng t√¨m th·∫•y t√≠nh nƒÉng n√†o, tr·∫£ v·ªÅ []
        """
        
        prompt = f"Tr√≠ch xu·∫•t t√≠nh nƒÉng t·ª´: '{text}'"
        result = self._call_gemini(prompt, system_instruction)
        
        if result:
            try:
                cleaned_result = self._clean_json_response(result)
                features = json.loads(cleaned_result)
                if isinstance(features, list):
                    return features
            except json.JSONDecodeError:
                logger.warning(f"‚ö†Ô∏è Could not parse features result: {result}")
        
        return []
    
    def extract_location_from_text(self, text: str) -> Optional[str]:
        """Extract location information from text using Gemini AI"""
        if not text:
            return None
        
        system_instruction = """
        Tr√≠ch xu·∫•t th√¥ng tin ƒë·ªãa ƒëi·ªÉm t·ª´ ƒëo·∫°n vƒÉn b·∫£n.
        
        T√¨m c√°c ƒë·ªãa ƒëi·ªÉm nh∆∞: qu·∫≠n, huy·ªán, th√†nh ph·ªë, t·ªânh
        Tr·∫£ v·ªÅ ƒë·ªãa ƒëi·ªÉm ch√≠nh x√°c nh·∫•t t√¨m ƒë∆∞·ª£c.
        N·∫øu kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm n√†o, tr·∫£ v·ªÅ null.
        """
        
        prompt = f"Tr√≠ch xu·∫•t ƒë·ªãa ƒëi·ªÉm t·ª´: '{text}'"
        result = self._call_gemini(prompt, system_instruction)
        
        if result and result.lower() != "null":
            return result.strip()
        
        return None
    
    def analyze_search_intent(self, text: str) -> Dict[str, Any]:
        """Analyze search intent from user input using Gemini AI"""
        if not text or not self.is_available():
            return {}
        
        system_instruction = """
        Ph√¢n t√≠ch √Ω ƒë·ªãnh t√¨m ki·∫øm t·ª´ y√™u c·∫ßu c·ªßa ng∆∞·ªùi d√πng v√† tr·∫£ v·ªÅ th√¥ng tin chi ti·∫øt.
        
        CH·ªà tr·∫£ v·ªÅ JSON thu·∫ßn t√∫y, KH√îNG c√≥ markdown code blocks:
        {
            "intent": "product_search|price_check|comparison|general_info",
            "product_type": "phone|accessory|service",
            "budget_range": {"min": s·ªë_nguy√™n_ho·∫∑c_null, "max": s·ªë_nguy√™n_ho·∫∑c_null},
            "brands": ["brand1", "brand2"],
            "features": ["feature1", "feature2"],
            "location": "ƒë·ªãa_ƒëi·ªÉm_ho·∫∑c_null",
            "urgency": "high|medium|low",
            "search_query": "t·ª´_kh√≥a_t√¨m_ki·∫øm_t·ªëi_∆∞u"
        }
        """
        
        prompt = f"Ph√¢n t√≠ch √Ω ƒë·ªãnh t√¨m ki·∫øm t·ª´: '{text}'"
        result = self._call_gemini(prompt, system_instruction)
        
        if result:
            try:
                cleaned_result = self._clean_json_response(result)
                intent_data = json.loads(cleaned_result)
                return intent_data
            except json.JSONDecodeError:
                logger.warning(f"‚ö†Ô∏è Could not parse intent result: {result}")
        
        return {}
    
    def generate_product_recommendation(self, user_requirements: Dict[str, Any], available_products: List[Dict[str, Any]]) -> str:
        """Generate product recommendation using Gemini AI"""
        if not user_requirements or not available_products or not self.is_available():
            return "Kh√¥ng c√≥ th√¥ng tin ƒë·ªß ƒë·ªÉ ƒë∆∞a ra g·ª£i √Ω."
        
        system_instruction = """
        D·ª±a tr√™n y√™u c·∫ßu c·ªßa ng∆∞·ªùi d√πng v√† danh s√°ch s·∫£n ph·∫©m c√≥ s·∫µn, ƒë∆∞a ra g·ª£i √Ω s·∫£n ph·∫©m ph√π h·ª£p nh·∫•t.
        
        Ph√¢n t√≠ch:
        1. So s√°nh y√™u c·∫ßu v·ªõi ƒë·∫∑c ƒëi·ªÉm s·∫£n ph·∫©m
        2. ƒê√°nh gi√° m·ª©c ƒë·ªô ph√π h·ª£p
        3. ƒê∆∞a ra l√Ω do c·ª• th·ªÉ
        4. G·ª£i √Ω s·∫£n ph·∫©m t·ªët nh·∫•t
        
        Tr·∫£ v·ªÅ vƒÉn b·∫£n t∆∞ v·∫•n ng·∫Øn g·ªçn, d·ªÖ hi·ªÉu.
        """
        
        prompt = f"""
        Y√™u c·∫ßu ng∆∞·ªùi d√πng: {json.dumps(user_requirements, ensure_ascii=False)}
        
        S·∫£n ph·∫©m c√≥ s·∫µn: {json.dumps(available_products[:5], ensure_ascii=False)}
        
        ƒê∆∞a ra g·ª£i √Ω s·∫£n ph·∫©m ph√π h·ª£p nh·∫•t.
        """
        
        result = self._call_gemini(prompt, system_instruction)
        return result or "Kh√¥ng th·ªÉ ƒë∆∞a ra g·ª£i √Ω t·∫°i th·ªùi ƒëi·ªÉm n√†y."

# Global instance
gemini_utils = GeminiUtilsTool()
